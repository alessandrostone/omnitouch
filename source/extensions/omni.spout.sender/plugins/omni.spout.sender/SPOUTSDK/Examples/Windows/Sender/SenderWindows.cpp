/*
=========================================================================

                      SenderWindows.cpp

					Basic OpenGL Spout sender

    A Windows Desktop Application project generated by Visual Studio
    and adapted for Spout sender output (https://spout.zeal.co/).

	This is an example using SpoutGL SendImage and SendTexture

	bool SendImage(const unsigned char* pixels, 
	               unsigned int width, unsigned int height,
				   GLenum glFormat, bool bInvert, GLuint HostFBO)

	bool SendTexture(GLuint TextureID, GLuint TextureTarget,
	                 unsigned int width, unsigned int height,
					 bool bInvert, GLuint HostFBO);

    This application captures the screen to a pixel buffer using Windows
	bitmap functions. The screen can be resized to demonstrate sender update.

	Search on "SPOUT" for additions.

	Compare with the Openframeworks "Sender > Graphics" example
    and with the DirectX 11 Windows sender example "Tutorial04" using SpoutDX.

	Openframeworks examples also demonstrate options such as synchronisation,
	data exchange and utility functions.

	---------------------------------------------------------------------------
				 
				 Copyright(C) 2024 Lynn Jarvis.

    This program is free software : you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program.If not, see < http://www.gnu.org/licenses/>.

===============================================================================
*/


#include "framework.h"
#include "SenderWindows.h"

#define MAX_LOADSTRING 100

// Global Variables:
HINSTANCE hInst;                      // current instance
WCHAR szTitle[MAX_LOADSTRING];        // The title bar text
WCHAR szWindowClass[MAX_LOADSTRING];  // the main window class name
int WindowPosLeft = 0;
int WindowPosTop = 0;
int window_width = 0;
int window_height = 0;

// SPOUT
Spout sender;                           // OpenGL sender object
HWND g_hWnd = NULL;                     // Window handle
HBITMAP g_hBitmap = NULL;               // Image bitmap for window capture
unsigned int g_BitmapWidth = 0;         // Image bitmap width
unsigned int g_BitmapHeight = 0;        // Image bitmap height
unsigned char *g_pixelBuffer = nullptr; // Sending pixel buffer
GLuint g_TextureGL;                     // SendTexture example

static char g_SenderName[256]{};        // Sender name for user entry
unsigned int g_SenderWidth = 0;         // Sender width
unsigned int g_SenderHeight = 0;        // Sender height

// Forward declarations of functions included in this code module:
ATOM                MyRegisterClass(HINSTANCE hInstance);
BOOL                InitInstance(HINSTANCE, int);
LRESULT CALLBACK    WndProc(HWND, UINT, WPARAM, LPARAM);

// SPOUT
void Render();

int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
	_In_opt_ HINSTANCE hPrevInstance,
	_In_ LPWSTR    lpCmdLine,
	_In_ int       nCmdShow)
{
	UNREFERENCED_PARAMETER(hPrevInstance);
	UNREFERENCED_PARAMETER(lpCmdLine);

	// Load bitmap from resources
	g_hBitmap = (HBITMAP)LoadImageA(GetModuleHandle(NULL), MAKEINTRESOURCEA(IDB_WINSPOUTBMP), IMAGE_BITMAP, 0, 0, LR_DEFAULTCOLOR);
	if (!g_hBitmap) {
		MessageBoxA(NULL, "Failed to load image", "SenderWindows", MB_OK);
		return FALSE;
	}

	// Get the size of the bitmap
	BITMAP bmpImage ={};
	GetObjectA(g_hBitmap, sizeof(BITMAP), &bmpImage);
	g_BitmapWidth = bmpImage.bmWidth;
	g_BitmapHeight = bmpImage.bmHeight;

	// Initialize global strings
	LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
	LoadStringW(hInstance, IDC_WINSPOUTGL, szWindowClass, MAX_LOADSTRING);
	MyRegisterClass(hInstance);

	// Perform application initialization:
	if (!InitInstance(hInstance, nCmdShow))
	{
		return FALSE;
	}

	// ---------------------------------------------------------------------------
	//
	// SPOUT
	//

	// Initialize OpenGL
	if (!sender.CreateOpenGL()) {
		SpoutMessageBox(NULL, "CreateOpenGL failed", "Windows OpenGL sender", MB_OK | MB_ICONWARNING);
		return FALSE;
	}

	// Create a sending buffer of inital size
	// It is resized as necessary - see WM_PAINT
	g_SenderWidth  = g_BitmapWidth;
	g_SenderHeight = g_BitmapHeight;
	unsigned int buffersize = g_SenderWidth * g_SenderHeight * 4;
	g_pixelBuffer = new unsigned char[buffersize];

	// Create an OpenGL texture for the SendTexture option
	// (Windows screen capture pixels are BGRA)
	sender.InitTexture(g_TextureGL, GL_BGRA, g_SenderWidth, g_SenderHeight);

	//
	// Give the sender a name
	//
	// If none is specified, the executable name is used
	// A global name is used for user sender name change
	// See further details in IDM_SENDER
	sprintf_s(g_SenderName, 256, "Windows OpenGL sender");
	sender.SetSenderName(g_SenderName);
	// Set the name in the Window caption
	SetWindowTextA(g_hWnd, sender.GetName());

	// ========== OPTIONS ==========

	// Open an empty console for debugging
	// OpenSpoutConsole();

	//
	// Logs
	//
	// Enable console logging to detect Spout warnings and errors
	// Logging functions are in a namespace and can be called directly
	// EnableSpoutLog();
	//
	// Logs report information, warnings and errors as well as user logs
	//
	// You can set the level above which the logs are shown
	// SPOUT_LOG_SILENT  : SPOUT_LOG_VERBOSE : SPOUT_LOG_NOTICE (default)
	// SPOUT_LOG_WARNING : SPOUT_LOG_ERROR   : SPOUT_LOG_FATAL
	// For example, to show only warnings and errors (you shouldn't see any)
	// or leave set to default Notice to see more information.
	//    SetSpoutLogLevel(SPOUT_LOG_WARNING);
	//
	// You can instead, or additionally, specify output to a text file
	// with the extension of your choice
	//    EnableSpoutLogFile("OF Spout Graphics sender.log");
	//
	// The log file is re-created every time the application starts
	// unless you specify to append to the existing one :
	//    EnableSpoutLogFile("OF Spout Graphics sender.log", true);
	//
	// The file is saved in the %AppData% folder 
	//    C:>Users>username>AppData>Roaming>Spout
	// unless you specify the full path.
	// After the application has run you can find and examine the log file
	//
	// This folder can also be shown in Windows Explorer directly from the application.
	//    ShowSpoutLogs();
	//
	// Or the entire log can be returned as a string
	//    std::string logstring = GetSpoutLog();
	//
	// You can also create your own logs
	// For example :
	//    SpoutLog("SpoutLog test");
	//
	// Or specify the logging level :
	// For example :
	//    SpoutLogNotice("Important notice");
	// or :
	//    SpoutLogFatal("This should not happen");
	// or :
	//    SetSpoutLogLevel(SPOUT_LOG_VERBOSE);
	//    SpoutLogVerbose("Message");
	//
	// Refer to the "SpoutUtils.cpp" source code for further details.
	//

	//
	// SpoutMessageBox
	//
	// SpoutMessageBox is an enhanced MessageBox using "TaskDialogIndirect"
	// and is useful to present user notices with options that are not
	// available with a standard MessageBox.
	//
	// Enhancements include :
	//   Custom icon
	//   Modeless mode
	//   Centre on the application window or desktop
	//   Message with variable arguments
	//   Text entry edit control
	//   Combobox item selection control
	//   Timeout option
	//   Multiple buttons
	//   Hyperlinks anywhere in the message text
	//
	// A practical example is used for change of sender name (IDM_SENDER)
	// See more details in the Openframeworks Sender > Utilities example.
	//

	//
	// Other options
	//
	// Refer to "SpoutUtils.cpp" source code for documentation.
	//     Spout SDK version number
	//     Registry utilities
	//     Computer information
	//     Timing utilities

	//
	// Sharing mode
	//
	// Use of texture sharing by GPU or CPU depends on user settings (SpoutSettings)
	// and compatibility with the OpenGL/DirectX interop functions, which is tested.
	//
	// User settings can be retrieved
	//     bool GetAutoShare();
	//     bool GetCPUshare();
	// As well as the mode being used by the application
	//     bool GetGLDX();
	//     bool GetCPU();
	// Hardware compatibility can be retrieved
	//     bool IsGLDXready();
	// And also re-tested
	//     bool GetGLDXready();
	//
	// The auto detect and CPU share options set by the user are global
	// but can be enabled or disabled for individual applications
	// without affecting the global settings.
	//     sender.SetAutoShare(true/false);
	//     sender.SetCPU(true/false);

	//
	// Graphics preference
	//
	// Windows Graphics performance preferences are available from Windows
	// Version 1803 (build 17134) and later.
	// "Settings > System > Display > Graphics settings".
	// These settings apply laptops with multiple graphics that allow power saving.
	// Spout texture sharing requires "High performance" peference.
	// Both Sender and Receiver must be set to the same preference.
	// Spout functions allow programmer control over the settings.
	// Refer to "SpoutSettings" help or "Spout.cpp/.h" source code for further details.
	//

	//
	// Frame counting
	//
	// Frame counting is enabled by default.
	// This allows a sender to signal a new frame and increment a frame count
	// semaphore which receivers can read and determine the sender frame rate
	//
	//    long receiver.GetSenderFrame();
	//    double receiver.GetSenderFps();
	//
	// Status can be queried with IsFrameCountEnabled();
	//
	// Frame counting can be independently disabled for this application
	//     sender.DisableFrameCount();
	//
	// Option - Set the frame rate of the application - see Render()
	// Applications without frame rate control can use : 
	//     void HoldFps(int fps);
	//

	//
	// Sender format
	//
	// The application OpenGL format can be changed
	// See details in the Openframeworks Sender > Graphics example 
	//
	// ---------------------------------------------------------------------------


    // Main message loop:
	MSG msg = { 0 };
	while (WM_QUIT != msg.message)
	{
		if (PeekMessage(&msg, nullptr, 0, 0, PM_REMOVE))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
		Render();
	}

	// ----------------------------------
	// SPOUT

	if(g_hBitmap) 
		DeleteObject(g_hBitmap);

	if (g_pixelBuffer) 
		delete[] g_pixelBuffer;

	// Release the sender
	sender.ReleaseSender();

	// Release OpenGL resources
	sender.CloseOpenGL();

	// ----------------------------------

    return (int) msg.wParam;
}

// SPOUT
void Render()
{

	// Trigger a re-paint to draw the bitmap
	// and refresh the sending pixel buffer - see WM_PAINT
	InvalidateRect(g_hWnd, NULL, FALSE);
	UpdateWindow(g_hWnd); // Update immediately

	// A pixel buffer and OpenGL texture are produced in WM_PAINT
	// The pixel buffer and texture are updated for window size changes

	//
	// Option 1) - Send image pixels
	//
	// SendImage manages sender create and re-size
	// RGBA, BGRA, RGB, BGR are supported
	// Windows screen capture pixels are BGRA
	// sender.SendImage(g_pixelBuffer, g_SenderWidth, g_SenderHeight, GL_BGRA);

	// Option 2) - Send texture
	// In this example, pixels are be loaded to the texture (see WM_PAINT)
	// In most OpenGL applications, a texture is available directly
	// See details in the Openframeworks Sender > Graphics example
	// The texture is initialized GL_BGRA to match Windows pixel format
	sender.SendTexture(g_TextureGL, GL_TEXTURE_2D, g_SenderWidth, g_SenderHeight, false); // No invert

	// Option - SendFbo is not available for this example
	// See details in the Openframeworks Sender > Graphics example

	//
	// Fps control
	//
	// Hold a target frame rate - e.g. 60 or 30fps.
	// Not necessary if the application already has fps control
	// but in this example, render rate can be extremely high if 
	// graphics driver "wait for vertical refresh" is disabled.
	sender.HoldFps(60);

}


//
//  FUNCTION: MyRegisterClass()
//
//  PURPOSE: Registers the window class.
//
ATOM MyRegisterClass(HINSTANCE hInstance)
{
    WNDCLASSEXW wcex;

    wcex.cbSize = sizeof(WNDCLASSEX);

    wcex.style          = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc    = WndProc;
    wcex.cbClsExtra     = 0;
    wcex.cbWndExtra     = 0;
    wcex.hInstance      = hInstance;
    wcex.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_WINSPOUTGL));
    wcex.hCursor        = LoadCursor(nullptr, IDC_ARROW);
	// SPOUT
	// wcex.hbrBackground  = (HBRUSH)(COLOR_WINDOW+1);
	wcex.hbrBackground  = CreateHatchBrush(HS_DIAGCROSS, RGB(192, 192, 192));
    wcex.lpszMenuName   = MAKEINTRESOURCEW(IDC_WINSPOUTGL);
    wcex.lpszClassName  = szWindowClass;
	wcex.hIconSm = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_WINSPOUTGL));

    return RegisterClassExW(&wcex);
}

//
//   FUNCTION: InitInstance(HINSTANCE, int)
//
//   PURPOSE: Saves instance handle and creates main window
//
//   COMMENTS:
//
//        In this function, we save the instance handle in a global variable and
//        create and display the main program window.
//
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
   hInst = hInstance; // Store instance handle in our global variable

   // Create window
   RECT rc = { 0, 0, 640, 360 }; // Desired client size
   AdjustWindowRect(&rc, WS_CAPTION | WS_SYSMENU | WS_THICKFRAME, TRUE);
   HWND hWnd = CreateWindowW(szWindowClass, szTitle,
   	   // SPOUT - enable resize and maximize to demonstrate sender resizing
	   WS_OVERLAPPEDWINDOW,
	   CW_USEDEFAULT, CW_USEDEFAULT, 
	   rc.right - rc.left, rc.bottom - rc.top, nullptr, nullptr, hInstance, nullptr);

   if (!hWnd)
   {
      return FALSE;
   }

   // SPOUT
   // Centre the window on the desktop work area
   GetWindowRect(hWnd, &rc);
   RECT WorkArea;
   SystemParametersInfo(SPI_GETWORKAREA, 0, (LPVOID)&WorkArea, 0);
   WindowPosLeft += ((WorkArea.right  - WorkArea.left) - (rc.right - rc.left)) / 2;
   WindowPosTop  += ((WorkArea.bottom - WorkArea.top)  - (rc.bottom - rc.top)) / 2;
   MoveWindow(hWnd, WindowPosLeft, WindowPosTop, (rc.right - rc.left), (rc.bottom - rc.top), false);

   ShowWindow(hWnd, nCmdShow);
   UpdateWindow(hWnd);

   g_hWnd = hWnd;
  
   return TRUE;
}

//
//  FUNCTION: WndProc(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE: Processes messages for the main window.
//
//  WM_COMMAND  - process the application menu
//  WM_PAINT    - Paint the main window
//  WM_DESTROY  - post a quit message and return
//
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_COMMAND:
        {
            int wmId = LOWORD(wParam);
            // Parse the menu selections:
            switch (wmId)
            {
				// SPOUT
				// Pop up a SpoutMessageBox edit control
				// for the user to change the sender name
				case IDM_SENDER:
				{
					std::string str = g_SenderName;
					if (SpoutMessageBox(hWnd, NULL, "Enter a new sender name", MB_OKCANCEL, str) == IDOK) {
						// Release the sender before changing the name
						// Another one with the new name is created when
						// SendImage or SendTexture are called again
						sender.ReleaseSender();
						// Update the sender name after releasing the sender
						strcpy_s(g_SenderName, 256, str.c_str());
						sender.SetSenderName(g_SenderName);
						// Set the window text with the new name
						SetWindowTextA(g_hWnd, g_SenderName);
					}
				}
				break;

				case IDM_ABOUT:
				{
					std::string about = "                    Windows OpenGL\n";
					about += "               Spout sender example\n\n";
					about += "                'File > Sender name'\n";
					about += "    to enter a new name for the sender\n\n";

					about += "                <a href=\"http://spout.zeal.co/\">http://spout.zeal.co</a>\n";
					// Custom icon for the SpoutMessagBox, activated by MB_USERICON
					SpoutMessageBoxIcon(LoadIconA(GetModuleHandle(NULL), MAKEINTRESOURCEA(IDI_WINSPOUTGL)));
					// Centre on the application window
					SpoutMessageBoxWindow(hWnd);
					SpoutMessageBox(NULL, (LPSTR)about.c_str(), "SenderWindows", MB_USERICON | MB_OK);
				}
                break;
            case IDM_EXIT:
                DestroyWindow(hWnd);
                break;
            default:
                return DefWindowProc(hWnd, message, wParam, lParam);
            }
        }
        break;

	// ESC to quit
	case WM_KEYDOWN:
	{
		if (wParam == VK_ESCAPE)
			PostQuitMessage(0);
		break;
	}

    case WM_PAINT:
        {
			if (IsIconic(hWnd))
				break;

			PAINTSTRUCT ps;
			HDC hdc = BeginPaint(g_hWnd, &ps);

			// For this example, draw an image, capture the client area
			// and copy pixel data to the sending buffer.

			//
			// Draw the image bitmap
			//
			
			// Get the client area
			RECT rcClient;
			GetClientRect(hWnd, &rcClient);
			UINT rcWidth = (rcClient.right - rcClient.left);
			UINT rcHeight = (rcClient.bottom - rcClient.top);

			// Create a compatible memory DC and select the image bitmap into it
			HDC hdcMemDC = CreateCompatibleDC(hdc);
			SelectObject(hdcMemDC, g_hBitmap);

			// Stretch blit the image to the client area
			SetStretchBltMode(hdc, COLORONCOLOR); // Fastest method
			StretchBlt(hdc,	0, 0,
						rcWidth, rcHeight, // client size
						hdcMemDC, 0, 0,
						g_BitmapWidth, g_BitmapHeight, // image size
						SRCCOPY);

			//
			// Capture the client area for sending
			//

			// The window is re-sizable - check for client area size change
			if (rcWidth != g_SenderWidth || rcHeight != g_SenderHeight) {
				// Update the sender dimensions
				g_SenderWidth  = rcWidth;
				g_SenderHeight = rcHeight;
				// Re-size the the sending buffer to match
				if(g_pixelBuffer) delete[] g_pixelBuffer;
				unsigned int buffersize = g_SenderWidth * g_SenderHeight * 4;
				g_pixelBuffer = new unsigned char[buffersize];
				// Update the example texture as well
				sender.InitTexture(g_TextureGL, GL_BGRA, g_SenderWidth, g_SenderHeight);
			}
			// The sender is now the same size as the client area

			// Create a compatible bitmap sized to the client area
			HBITMAP hBitmap = CreateCompatibleBitmap(hdcMemDC, rcWidth, rcHeight);

			// Select the bitmap into the memory DC
			HBITMAP hOldBitmap = (HBITMAP)SelectObject(hdcMemDC, hBitmap);

			// Blit the client screen into it
			BitBlt(hdcMemDC, 0, 0,
				   rcClient.right - rcClient.left,
				   rcClient.bottom - rcClient.top,
				   hdc, 0, 0, SRCCOPY);

			// Copy to our sending buffer
			GetBitmapBits(hBitmap, rcWidth*rcHeight*4, (LPVOID)g_pixelBuffer);

			// Windows screen capture produces alpha 0 for the whole image.
			// Some applications display the received image as black,
			// so alpha of all the pixels should be converted to 255. 
			// See also : http://www.winprog.org/tutorial/transparency.html
			// The following function consumes approximately 1.5 msec at 1920x1080
			sender.spoutcopy.ClearAlpha(g_pixelBuffer, g_SenderWidth, g_SenderHeight, 255);

			// Fill the texture with the pixels for this example 
			// (SendImage uses the same function)
			glBindTexture(GL_TEXTURE_2D, g_TextureGL);
			glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, g_SenderWidth, g_SenderHeight, GL_BGRA, GL_UNSIGNED_BYTE, (GLvoid*)g_pixelBuffer);
			glBindTexture(GL_TEXTURE_2D, 0);

			// Clean up
			SelectObject(hdcMemDC, hOldBitmap);
			DeleteObject(hBitmap);
			DeleteDC(hdcMemDC);
		
			EndPaint(hWnd, &ps);

        }
        break;

	case WM_DESTROY:
        PostQuitMessage(0);
        break;

    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}

// That's all..
